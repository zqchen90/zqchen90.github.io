<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zq90chen</title>
  <subtitle>积跬步  行千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zqchen90.github.io/"/>
  <updated>2018-08-28T13:24:36.000Z</updated>
  <id>http://zqchen90.github.io/</id>
  
  <author>
    <name>zqchen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>直观解读 KL 散度的数学概念</title>
    <link href="http://zqchen90.github.io/2018/04/05/new-%E7%9B%B4%E8%A7%82%E8%A7%A3%E8%AF%BBKL%E6%95%A3%E5%BA%A6%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A6%82%E5%BF%B5/"/>
    <id>http://zqchen90.github.io/2018/04/05/new-直观解读KL散度的数学概念/</id>
    <published>2018-04-05T11:19:53.000Z</published>
    <updated>2018-08-28T13:24:36.000Z</updated>
    
    <content type="html">&lt;p&gt;选自&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//thushv.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://thushv.com&lt;/a&gt;，作者：Thushan Ganegedara，机器之心编译。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;机器学习是当前最重要的技术发展方向之一。近日，悉尼大学博士生 Thushan Ganegedara 开始撰写一个系列博客文章，旨在为机器学习初学者介绍一些基本概念。本文是该系列的第一篇文章，介绍了 KL 散度（KL divergence）的基本数学概念和初级应用。作者已将相关代码发布在 GitHub 上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/thushv89/nlp_examples_thushv_dot_com/blob/master/kl_divergence.ipynb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/thushv89/nlp_examples_thushv_dot_com/blob/master/kl_divergence.ipynb&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;# 基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础概念 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 首先让我们确立一些基本规则。我们将会定义一些我们需要了解的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布（distribution）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布可能指代不同的东西，比如数据分布或概率分布。我们这里所涉及的是概率分布。假设你在一张纸上画了两根轴（即 X 和 Y），我可以将一个分布想成是落在这两根轴之间的一条线。其中 X 表示你有兴趣获取概率的不同值。Y 表示观察 X 轴上的值时所得到的概率。即 y=p(x)。下图即是某个分布的可视化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-e08e09c83fb470d2c225425715476220_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是一个连续概率分布。比如，我们可以将 X 轴看作是人的身高，Y 轴是找到对应身高的人的概率。&lt;/p&gt;
&lt;p&gt;如果你想得到离散的概率分布，你可以将这条线分成固定长度的片段并以某种方式将这些片段水平化。然后就能根据这条线的每个片段创建边缘互相连接的矩形。这就能得到一个离散概率分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件（event）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于离散概率分布而言，事件是指观察到 X 取某个值（比如 X=1）的情况。我们将事件 X=1 的概率记为 P(X=1)。在连续空间中，你可以将其看作是一个取值范围（比如 0.95&amp;lt;X&amp;lt;1.05）。注意，事件的定义并不局限于在 X 轴上取值。但是我们后面只会考虑这种情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回到 KL 散度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从这里开始，我将使用来自这篇博文的示例：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.countbayesie.com/blog/2017/5/9/kullback-leibler-divergence-explained&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.countbayesie.com/blog/2017/5/9/kullback-leibler-divergence-explained&lt;/a&gt;。这是一篇很好的 KL 散度介绍文章，但我觉得其中某些复杂的解释可以更详细的阐述。好了，让我们继续吧。&lt;/p&gt;
&lt;h2 id=&quot;我们想要解决的问题&quot;&gt;&lt;a href=&quot;# 我们想要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;我们想要解决的问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;我们想要解决的问题 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 上述博文中所解决的核心问题是这样的：假设我们是一组正在广袤无垠的太空中进行研究的科学家。我们发现了一些太空蠕虫，这些太空蠕虫的牙齿数量各不相同。现在我们需要将这些信息发回地球。但从太空向地球发送信息的成本很高，所以我们需要用尽量少的数据表达这些信息。我们有个好方法：我们不发送单个数值，而是绘制一张图表，其中 X 轴表示所观察到的不同牙齿数量（0,1,2…），Y 轴是看到的太空蠕虫具有 x 颗牙齿的概率（即具有 x 颗牙齿的蠕虫数量 / 蠕虫总数量）。这样，我们就将观察结果转换成了分布。&lt;/p&gt;
&lt;p&gt;发送分布比发送每只蠕虫的信息更高效。但我们还能进一步压缩数据大小。我们可以用一个已知的分布来表示这个分布（比如均匀分布、二项分布、正态分布）。举个例子，假如我们用均匀分布来表示真实分布，我们只需要发送两段数据就能恢复真实数据；均匀概率和蠕虫数量。但我们怎样才能知道哪种分布能更好地解释真实分布呢？这就是 KL 散度的用武之地。&lt;/p&gt;
&lt;p&gt;直观解释：KL 散度是一种衡量两个分布（比如两条线）之间的匹配程度的方法。&lt;/p&gt;
&lt;h2 id=&quot;让我们对示例进行一点修改&quot;&gt;&lt;a href=&quot;# 让我们对示例进行一点修改&quot; class=&quot;headerlink&quot; title=&quot;让我们对示例进行一点修改&quot;&gt;&lt;/a&gt;&lt;strong&gt;让我们对示例进行一点修改 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 为了能够检查数值的正确性，让我们将概率值修改成对人类更友好的值（相比于上述博文中的值）。我们进行如下假设：假设有 100 只蠕虫，各种牙齿数的蠕虫的数量统计结果如下。&lt;/p&gt;
&lt;p&gt;0 颗牙齿：2（概率：p_0 = 0.02）&lt;/p&gt;
&lt;p&gt;1 颗牙齿：3（概率：p_1 = 0.03）&lt;/p&gt;
&lt;p&gt;2 颗牙齿：5（概率：p_2 = 0.05）&lt;/p&gt;
&lt;p&gt;3 颗牙齿：14（概率：p_3 = 0.14&lt;/p&gt;
&lt;p&gt;4 颗牙齿：16（概率：p_4 = 0.16）&lt;/p&gt;
&lt;p&gt;5 颗牙齿：15（概率：p_5 = 0.15）&lt;/p&gt;
&lt;p&gt;6 颗牙齿：12（概率：p_6 = 0.12）&lt;/p&gt;
&lt;p&gt;7 颗牙齿：8（概率：p_7 = 0.08）&lt;/p&gt;
&lt;p&gt;8 颗牙齿：10（概率：p_8 = 0.1）&lt;/p&gt;
&lt;p&gt;9 颗牙齿：8（概率：p_9 = 0.08）&lt;/p&gt;
&lt;p&gt;10 颗牙齿：7（概率：p_10 = 0.07）&lt;/p&gt;
&lt;p&gt;快速做一次完整性检查！确保蠕虫总数为 100，且概率总和为 1.0.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蠕虫总数 = 2+3+5+14+16+15+12+8+10+8+7 = 100&lt;/li&gt;
&lt;li&gt;概率总和 = 0.02+0.03+0.05+0.14+0.16+0.15+0.12+0.08+0.1+0.08+0.07 = 1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可视化结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-5a892d206e0d293d08fece13e01d48ff_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;尝试 -1：使用均匀分布建模&quot;&gt;&lt;a href=&quot;# 尝试 -1：使用均匀分布建模&quot; class=&quot;headerlink&quot; title=&quot;尝试 1：使用均匀分布建模&quot;&gt;&lt;/a&gt;&lt;strong&gt;尝试 1：使用均匀分布建模 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 我们首先使用均匀分布来建模该分布。均匀分布只有一个参数：均匀概率；即给定事件发生的概率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-476d9eacd0ef4d008e5383fae2343cfd_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;均匀分布和我们的真实分布对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-584814bf1da439cf237e5463f193c8ab_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;先不讨论这个结果，我们再用另一种分布来建模真实分布。&lt;/p&gt;
&lt;h2 id=&quot;尝试 -2：使用二项分布建模&quot;&gt;&lt;a href=&quot;# 尝试 -2：使用二项分布建模&quot; class=&quot;headerlink&quot; title=&quot;尝试 2：使用二项分布建模&quot;&gt;&lt;/a&gt;&lt;strong&gt;尝试 2：使用二项分布建模 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 你可能计算过抛硬币正面或背面向上的概率，这就是一种二项分布概率。我们可以将同样的概念延展到我们的问题上。对于有两个可能输出的硬币，我们假设硬币正面向上的概率为 p，并且进行了 n 次尝试，那么其中成功 k 次的概率为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-6b2adff993559666a0c1d0bfc7e6872e_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公式解读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说明一下二项分布中每一项的含义。第一项是 p^k。我们想成功 k 次，其中单次成功的概率为 p；那么成功 k 次的概率为 p^k。另外要记得我们进行了 n 次尝试。因此，其中失败的次数为 n-k，对应失败的概率为 (1-p)。所以成功 k 次的概率即为联合概率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-443f7f40426d4c9995b41ff593fd73fd_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;。到此还未结束。在 n 次尝试中，k 次成功会有不同的排列方式。在数量为 n 的空间中 k 个元素的不同排列数量为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-90f932a81e0d18f22ae233685e428866_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;将所有这些项相乘就得到了成功 k 次的二项概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二项分布的均值和方差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还可以定义二项分布的均值和方差，如下：&lt;/p&gt;
&lt;p&gt;均值 = np&lt;/p&gt;
&lt;p&gt;方差 = np(1-p)&lt;/p&gt;
&lt;p&gt;均值是什么意思？均值是指你进行 n 次尝试时的期望（平均）成功次数。如果每次尝试成功的概率为 p，那么可以说 n 次尝试的成功次数为 np。&lt;/p&gt;
&lt;p&gt;方差又是什么意思？它表示真实的成功尝试次数偏离均值的程度。为了理解方差，让我们假设 n=1，那么等式就成了「方差 = p(1-p)」。那么当 p=0.5 时（正面和背面向上的概率一样），方差最大；当 p=1 或 p=0 时（只能得到正面或背面中的一种），方差最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回来继续建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经理解了二项分布，接下来回到我们之前的问题。首先让我们计算蠕虫的牙齿的期望数量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-a40ca4f93a20a6cdd1b7e3ab1ac731ae_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;有了均值，我们可以计算 p 的值：&lt;/p&gt;
&lt;p&gt;均值 = np&lt;/p&gt;
&lt;p&gt;5.44 = 10p&lt;/p&gt;
&lt;p&gt;p = 0.544&lt;/p&gt;
&lt;p&gt;注意，这里的 n 是指在蠕虫中观察到的最大牙齿数。你可能会问我们为什么不把蠕虫总数（即 100）或总事件数（即 11）设为 n。我们很快就将看到原因。有了这些数据，我们可以按如下方式定义任意牙齿数的概率。&lt;/p&gt;
&lt;p&gt;鉴于牙齿数的取值最大为 10，那么看见 k 颗牙齿的概率是多少（这里看见一颗牙齿即为一次成功尝试）？&lt;/p&gt;
&lt;p&gt;从抛硬币的角度看，这就类似于：&lt;/p&gt;
&lt;p&gt;假设我抛 10 次硬币，观察到 k 次正面向上的概率是多少？&lt;/p&gt;
&lt;p&gt;从形式上讲，我们可以计算所有不同 k 值的概率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-632aaf77a64e8ef2859eebaca9594f8e_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;。其中 k 是我们希望观察到的牙齿数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-632aaf77a64e8ef2859eebaca9594f8e_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;是第 k 个牙齿数量位置（即 0 颗牙齿、1 颗牙齿……）的二项概率。所以，计算结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-1d9a5000f353a67e80033c7367c12232_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们的真实分布和二项分布的比较如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-8c8e4dc743f81af38d7e8762b1fd2231_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结已有情况&quot;&gt;&lt;a href=&quot;# 总结已有情况&quot; class=&quot;headerlink&quot; title=&quot;总结已有情况&quot;&gt;&lt;/a&gt;&lt;strong&gt;总结已有情况 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 现在回头看看我们已经完成的工作。首先，我们理解了我们想要解决的问题。我们的问题是将特定类型的太空蠕虫的牙齿数据统计用尽量小的数据量发回地球。为此，我们想到用某个已知分布来表示真实的蠕虫统计数据，这样我们就可以只发送该分布的参数，而无需发送真实统计数据。我们检查了两种类型的分布，得到了以下结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;均匀分布——概率为 0.0909&lt;/li&gt;
&lt;li&gt;二项分布——n=10、p=0.544，k 取值在 0 到 10 之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们在同一个地方可视化这三个分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-e1d68f8696a1d8fed6335f62098e0b07_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;我们如何定量地确定哪个分布更好？&quot;&gt;&lt;a href=&quot;# 我们如何定量地确定哪个分布更好？&quot; class=&quot;headerlink&quot; title=&quot;我们如何定量地确定哪个分布更好？&quot;&gt;&lt;/a&gt;&lt;strong&gt;我们如何定量地确定哪个分布更好？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;经过这些计算之后，我们需要一种衡量每个近似分布与真实分布之间匹配程度的方法。这很重要，这样当我们发送信息时，我们才无需担忧「我是否选择对了？」毕竟太空蠕虫关乎我们每个人的生命。&lt;/p&gt;
&lt;p&gt;这就是 KL 散度的用武之地。KL 散度在形式上定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-5d00e4e599d11ea5001ce86d25d1d8e8_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中 q(x) 是近似分布，p(x) 是我们想要用 q(x) 匹配的真实分布。直观地说，这衡量的是给定任意分布偏离真实分布的程度。如果两个分布完全匹配，那么&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-688571c67bed27d564566ebc8bc6682e_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;，否则它的取值应该是在 0 到无穷大（inf）之间。KL 散度越小，真实分布与近似分布之间的匹配就越好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KL 散度的直观解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们看看 KL 散度各个部分的含义。首先看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-2f197d8678ee9cf9475db0ad9f04b276_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;项。如果 q(x_i) 大于 p(x_i) 会怎样呢？此时这个项的值为负，因为小于 1 的值的对数为负。另一方面，如果 q(x_i) 总是小于 p(x_i)，那么该项的值为正。如果 p(x_i)=q(x_i) 则该项的值为 0。然后，为了使这个值为期望值，你要用 p(x_i) 来给这个对数项加权。也就是说，p(x_i) 有更高概率的匹配区域比低 p(x_i) 概率的匹配区域更加重要。&lt;/p&gt;
&lt;p&gt;直观而言，优先正确匹配近似分布中真正高可能性的事件是有实际价值的。从数学上讲，这能让你自动忽略落在真实分布的支集（支集（support）是指分布使用的 X 轴的全长度）之外的分布区域。另外，这还能避免计算 log(0) 的情况——如果你试图计算落在真实分布的支集之外的任意区域的这个对数项，就可能出现这种情况。&lt;/p&gt;
&lt;h2 id=&quot;计算 -KL- 散度&quot;&gt;&lt;a href=&quot;# 计算 -KL- 散度&quot; class=&quot;headerlink&quot; title=&quot;计算 KL 散度&quot;&gt;&lt;/a&gt;&lt;strong&gt;计算 KL 散度 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 我们计算一下上面两个近似分布与真实分布之间的 KL 散度。首先来看均匀分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-662e3b4ac725186f70e279f6925714d3_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;再看看二项分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-fa90d2f4cb749570a3a207c82974f29a_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;玩一玩 -KL- 散度&quot;&gt;&lt;a href=&quot;# 玩一玩 -KL- 散度&quot; class=&quot;headerlink&quot; title=&quot;玩一玩 KL 散度&quot;&gt;&lt;/a&gt;&lt;strong&gt;玩一玩 KL 散度 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 现在，我们来玩一玩 KL 散度。首先我们会先看看当二元分布的成功概率变化时 KL 散度的变化情况。不幸的是，我们不能使用均匀分布做同样的事，因为 n 固定时均匀分布的概率不会变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-18d2bdf034915c8012c3da0d9bda6edb_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当我们远离我们的选择（红点）时，KL 散度会快速增大。实际上，如果你显示输出我们的选择周围小 Δ 数量的 KL 散度值，你会看到我们选择的成功概率的 KL 散度最小。&lt;/p&gt;
&lt;p&gt;现在让我们看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-1e90c0fd2bfbffba292ddcfc0b75a32b_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-b62afb104f60f0b1cbdd74b9eb1f0ff5_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;的行为方式。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-e7b9f275dd78dcacd352c925f3de2be8_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来有一个区域中的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-1e90c0fd2bfbffba292ddcfc0b75a32b_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-b62afb104f60f0b1cbdd74b9eb1f0ff5_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;之间有最小的距离。让我们绘出两条线之间的差异（虚线），并且放大我们的概率选择所在的区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-f8ce9d4f62094e2b334d877dc4fb9efd_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来我们的概率选择也位于非常接近&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-1e90c0fd2bfbffba292ddcfc0b75a32b_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-b62afb104f60f0b1cbdd74b9eb1f0ff5_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;有最低差异的区域（但并不是最低差异的区域）。但这仍然是一个很有意思的发现。我不确定出现这种情况的原因是什么。如果有人知道，欢迎讨论。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;# 结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;&lt;strong&gt;结论 &lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; 现在我们有些可靠的结果了。尽管均匀分布看起来很简单且信息不多而二项分布带有更有差别的信息，但实际上均匀分布与真实分布之间的匹配程度比二项分布的匹配程度更高。说老实话，这个结果实际上让我有点惊讶。因为我之前预计二项分布能更好地建模这个真实分布。因此，这个实验也能告诉我们：不要只相信自己的直觉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-18cc987d5f379a82f1208b6d90722318_hd.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.thushv.com/machine-learning/light-on-math-machine-learning-intuitive-guide-to-understanding-kl-divergence/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.thushv.com/machine-learning/light-on-math-machine-learning-intuitive-guide-to-understanding-kl-divergence/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;选自&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//thushv.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://thushv.com&lt;/a&gt;，作者：Thushan Ganegedara
    
    </summary>
    
      <category term="ML" scheme="http://zqchen90.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="http://zqchen90.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Weighted Shuffle 加权的随机打散算法的一种实现</title>
    <link href="http://zqchen90.github.io/2016/07/28/weigthed-shuffle/"/>
    <id>http://zqchen90.github.io/2016/07/28/weigthed-shuffle/</id>
    <published>2016-07-28T14:51:55.000Z</published>
    <updated>2016-07-31T08:06:37.000Z</updated>
    
    <content type="html">&lt;p&gt;Java 中的 Collection.shuffle(List&amp;lt;?&amp;gt; list)是一个可以将 List 中的元素随机打散的函数，但是在有些场景下，我们需要打散排好序的 List，比如有一组用户可能感兴趣的商品列表，用户可能多次看到这个列表，希望每次看到时列表的顺序是不同的。这就会用到 weighted shuffle 算法，既希望进行随机打散，又希望在 shuffle 的过程中能尽可能保持原有顺序。&lt;/p&gt;
&lt;h1 id=&quot;Collection-shuffle 的实现&quot;&gt;&lt;a href=&quot;#Collection-shuffle 的实现&quot; class=&quot;headerlink&quot; title=&quot;Collection.shuffle 的实现&quot;&gt;&lt;/a&gt;Collection.shuffle 的实现 &lt;/h1&gt;&lt;p&gt;Java 从 1.2 开始就引入了 java.util.Collections 这个类，关于&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#shuffle(java.util.List&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shuffle 方法&lt;/a&gt;) 的实现是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the “current position”. Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个实现将列表反转，从最后一个元素向前到第二个元素，重复随机选取一个元素与当前位置的元素交换。被交换元素是从列表第一个元素到当前元素（包括）的这部分中随机挑选的。&lt;/p&gt;
&lt;h1 id=&quot;一种 Weighted-Shuffle 算法&quot;&gt;&lt;a href=&quot;# 一种 Weighted-Shuffle 算法&quot; class=&quot;headerlink&quot; title=&quot;一种 Weighted Shuffle 算法&quot;&gt;&lt;/a&gt;一种 Weighted Shuffle 算法 &lt;/h1&gt;&lt;h2 id=&quot;从 shuffle 扩展&quot;&gt;&lt;a href=&quot;# 从 shuffle 扩展&quot; class=&quot;headerlink&quot; title=&quot;从 shuffle 扩展&quot;&gt;&lt;/a&gt; 从 shuffle 扩展 &lt;/h2&gt;&lt;p&gt; 我们可以从 Java Collection.shuffle 实现中交换的想法触发，扩展出一种 weighted shuffle 的算法。在 shuffle 方法中，可以不严格地认为两个元素是否发生交换的概率是 50%，我们只要调整这个概率，让排在有序列表前面的元素与排在后面的元素交换的概率更低就可以实现 weighted shuffle 了.&lt;/p&gt;
&lt;p&gt;比如，有序列表是一个 &lt;code&gt;List&amp;lt;WeightItem&amp;lt;E&amp;gt;&amp;gt;&lt;/code&gt; 类型的，&lt;code&gt;WeightItem&amp;lt;E&amp;gt;&lt;/code&gt;定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeightItem&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; E item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Double weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeightItem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(E item, Double weight)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.item = item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.weight = weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;title&quot;&gt;getItem&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       returnthis.item;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Double &lt;span class=&quot;title&quot;&gt;getWeight&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样就可以写出最核心的代码了&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Collections.sort(weightItemList, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Comparator&amp;lt;WeightItem&amp;gt;()&amp;#123;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(WeightItem s1, WeightItem s2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Math.random() * s1.getWeight() &amp;gt; Math.random() * s2.getWeight() ? -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于我们直接使用了 Collections 中的 sort 方法，所以这个 weighted shuffle 算法的空间复杂度是&lt;code&gt;O(n)&lt;/code&gt;，时间复杂度是&lt;code&gt;O(nlogn)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;概率有多大？&quot;&gt;&lt;a href=&quot;# 概率有多大？&quot; class=&quot;headerlink&quot; title=&quot;概率有多大？&quot;&gt;&lt;/a&gt;概率有多大？&lt;/h2&gt;&lt;p&gt;前面提到 weighted shuffle 是介于完全随机和完全保序之间，两个元素交换的概率到底有多大，我们可以算一算。&lt;/p&gt;
&lt;p&gt;假设有序列表中两个元素 Xm 和 Xn，它们的权重分别是 M 和 N，不妨设 M &amp;gt;= N，打散后 Xm 排在 Xn 后面的概率就等同于下面这个更数学化的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设随机变量 m 服从 [0, M] 之间均匀分布，随机变量 n 服从 [0, N] 之间均匀分布，M &amp;gt;= N，求 p(m &amp;lt; n)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;m 可能在 [0, N] 之间，也可能在 [N, M] 之间，按照条件概率分开可以写成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;p(m &amp;lt; n) = p(m &amp;lt; n | m &amp;gt; N) &lt;em&gt; p(m &amp;gt; N) + p(m &amp;lt; n | m &amp;lt;= N) &lt;/em&gt; p(m &amp;lt;= N).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上式中第一项为 0，第二项 p(m &amp;lt;= N)=N / M，而当 m &amp;lt;= N 时，m 的取值范围与 n 相同，所以 p(m &amp;lt; n | m &amp;lt;= N) = 1 / 2。所以：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; p(m&amp;lt;n) = N / 2M.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当 N = M 时，p(m &amp;lt; n) = 0.5，元素 Xm 和 Xn 的权重相同，Weighted Shuffle 退化成普通的 shuffle，元素间的交互是完全随机的；&lt;/li&gt;
&lt;li&gt;当 N = 0 是，p(m &amp;lt; n) = 1，元素 Xm 和 Xn 的顺序始终可以保持，不再是 shuffle 了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;更随机？还是更保序？&quot;&gt;&lt;a href=&quot;# 更随机？还是更保序？&quot; class=&quot;headerlink&quot; title=&quot;更随机？还是更保序？&quot;&gt;&lt;/a&gt;更随机？还是更保序？&lt;/h1&gt;&lt;p&gt;在对一个有序列表进行 weighted shuffle 的时候，我们面临两个方向的选择，让 shuffle 的结果更加随机，或者让结果更保持原有的顺序。这个问题通过对有序列表元素设置权重来完成。&lt;/p&gt;
&lt;p&gt;如果我们只是有一个有序列表，而没有每个元素对应的权重，有一种简单设置权重的方法，对于排列在 &lt;code&gt;i&lt;/code&gt; 位的元素，权重为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;w(i) = (L - i + 1) ^ alpha&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 L 为列表的长度，alpha 为控制偏向随机还是偏向保序的参数，取值范围是[0, +infinite)。我们可以比较排列在第一位和最后一位的两个元素在 shuffle 后交换顺序的概率：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;p = 1 / (2 * L^alpha)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当列表长度越大、alpha 取值越大时，概率越小；反之概率越大。&lt;/p&gt;
&lt;p&gt;为了直观展示参数的效果，这里列出几个例子：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;L&lt;/th&gt;
&lt;th&gt;alpha&lt;/th&gt;
&lt;th&gt;p&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;50.8%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;57.4%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;90.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;51.1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;60.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;95.0%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;0.01&lt;/td&gt;
&lt;td&gt;98.3%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;64.6%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;51.7%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;最后：还是概率&quot;&gt;&lt;a href=&quot;# 最后：还是概率&quot; class=&quot;headerlink&quot; title=&quot;最后：还是概率&quot;&gt;&lt;/a&gt;最后：还是概率 &lt;/h1&gt;&lt;p&gt; 本文的算法给出两个有序元素 shuffle 后的顺序改变的概率是 p(m&amp;lt;n) = N / 2M，这个概率并不适用于任何情况，比如当元素的权重有比较明确可比较的含义时，我们希望这个概率是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;p(m&amp;lt;n)=N / (N + M).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于这种情况，我们只要修改 weighted shuffle 算法中对排序交换条件的判断代码就可以实现了，具体做法这里就不做详细的介绍了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中的 Collection.shuffle(List&amp;lt;?&amp;gt; list)是一个可以将 List 中的元素随机打散的函数，但是在有些场景下，我们需要打散排好序的 List，比如有一组用户可能感兴趣的商品列表，用户可能多次看到这个列表，希望每次看到时列表的顺
    
    </summary>
    
      <category term="Java" scheme="http://zqchen90.github.io/categories/Java/"/>
    
      <category term="Algorithm" scheme="http://zqchen90.github.io/categories/Java/Algorithm/"/>
    
    
      <category term="shuffle" scheme="http://zqchen90.github.io/tags/shuffle/"/>
    
  </entry>
  
  <entry>
    <title>像 Git 一样思考（译）</title>
    <link href="http://zqchen90.github.io/2016/04/08/think-like-a-git/"/>
    <id>http://zqchen90.github.io/2016/04/08/think-like-a-git/</id>
    <published>2016-04-08T11:19:53.000Z</published>
    <updated>2016-06-26T07:26:41.000Z</updated>
    
    <content type="html">&lt;p&gt;译者注：本文翻译自 Sam Livingston-Gray 的文章&lt;a href=&quot;http://think-like-a-git.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Think Like (a) Git&lt;/a&gt;。我在学习 Git 的过程中无意看到了这篇文章，Sam 从图论的角度解释了 Git，让我明白了很多之前疑惑的地方。所以，我将这篇文章翻译成中文，希望能帮助更多学习 Git 的人。&lt;/p&gt;
&lt;h2 id=&quot;图论（Graph-Theory）&quot;&gt;&lt;a href=&quot;# 图论（Graph-Theory）&quot; class=&quot;headerlink&quot; title=&quot;图论（Graph Theory）&quot;&gt;&lt;/a&gt;图论（Graph Theory）&lt;/h2&gt;&lt;h3 id=&quot;Konigsberg 的七桥理论（Seven-Bridges-of-Konigsberg）&quot;&gt;&lt;a href=&quot;#Konigsberg 的七桥理论（Seven-Bridges-of-Konigsberg）&quot; class=&quot;headerlink&quot; title=&quot;Königsberg 的七桥理论（Seven Bridges of Königsberg）&quot;&gt;&lt;/a&gt;Königsberg 的七桥理论（Seven Bridges of Königsberg）&lt;/h3&gt;&lt;h3 id=&quot;Places-To-Go-and-Ways-to-Get-There&quot;&gt;&lt;a href=&quot;#Places-To-Go-and-Ways-to-Get-There&quot; class=&quot;headerlink&quot; title=&quot;Places To Go, and Ways to Get There&quot;&gt;&lt;/a&gt;Places To Go, and Ways to Get There&lt;/h3&gt;&lt;h3 id=&quot;Nodes-and-Edges&quot;&gt;&lt;a href=&quot;#Nodes-and-Edges&quot; class=&quot;headerlink&quot; title=&quot;Nodes and Edges&quot;&gt;&lt;/a&gt;Nodes and Edges&lt;/h3&gt;&lt;h3 id=&quot;Attaching-Labels-to-Nodes&quot;&gt;&lt;a href=&quot;#Attaching-Labels-to-Nodes&quot; class=&quot;headerlink&quot; title=&quot;Attaching Labels to Nodes&quot;&gt;&lt;/a&gt;Attaching Labels to Nodes&lt;/h3&gt;&lt;h3 id=&quot;Attaching-Labels-to-Edges&quot;&gt;&lt;a href=&quot;#Attaching-Labels-to-Edges&quot; class=&quot;headerlink&quot; title=&quot;Attaching Labels to Edges&quot;&gt;&lt;/a&gt;Attaching Labels to Edges&lt;/h3&gt;&lt;h3 id=&quot;Directed-Versus-Undirected-Graphs&quot;&gt;&lt;a href=&quot;#Directed-Versus-Undirected-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Directed Versus Undirected Graphs&quot;&gt;&lt;/a&gt;Directed Versus Undirected Graphs&lt;/h3&gt;&lt;h3 id=&quot;Reachability&quot;&gt;&lt;a href=&quot;#Reachability&quot; class=&quot;headerlink&quot; title=&quot;Reachability&quot;&gt;&lt;/a&gt;Reachability&lt;/h3&gt;&lt;h2 id=&quot;图和 Git（Graphs-and-Git）&quot;&gt;&lt;a href=&quot;# 图和 Git（Graphs-and-Git）&quot; class=&quot;headerlink&quot; title=&quot;图和 Git（Graphs and Git）&quot;&gt;&lt;/a&gt;图和 Git（Graphs and Git）&lt;/h2&gt;&lt;p&gt;我讨论了这么多关于图论内容的原因是 Git 就是一个巨大的图。&lt;/p&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/graphs-and-git.png&quot; alt=&quot;graphs-and-git.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;Git commits（简单的视角）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大部分时候，你使用 Git 都是通过这样那样的方式进行提交（commits），从表面上看，一次 Git 提交包括两部分：（1）在某个时刻，一个指向你的代码状态的指针（pointer）；（2）0 个或者多个指向父级提交的指针。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(提示：指针的含义和讨论图的时候一样)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次 Git 的 commit 就是图里的一个节点&lt;/strong&gt;，节点可以指向其他更早的节点。&lt;/p&gt;
&lt;p&gt;另外：如果你希望比一个理智的人类知道的更多，我非常推荐 Scott Chacon 的&lt;a href=&quot;http://peepcode.com/products/git-internals-pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDF&lt;/a&gt;。或者是任何 Scott Chacon 的讲座。Scott 关于 Git 的知识实在是……惊人。&lt;/p&gt;
&lt;h3 id=&quot;可视化你的 Git 仓库（Visualizing-Your-Git-Repository）&quot;&gt;&lt;a href=&quot;# 可视化你的 Git 仓库（Visualizing-Your-Git-Repository）&quot; class=&quot;headerlink&quot; title=&quot;可视化你的 Git 仓库（Visualizing Your Git Repository）&quot;&gt;&lt;/a&gt;可视化你的 Git 仓库（Visualizing Your Git Repository）&lt;/h3&gt;&lt;p&gt;我的大约一半的 Git 操作都是在命令行下进行的。&lt;strong&gt;但是如果我想知道正在发生什么&lt;/strong&gt;，我会使用 Git 的可视化工具。在 Mac 上，我能找到的最好的可视化工具是&lt;a href=&quot;http://gitx.frim.nl/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitX&lt;/a&gt;。其他操作系统上，可以使用&lt;strong&gt;gitk&lt;/strong&gt;，或者你可以在网上找到适合你的工具。&lt;/p&gt;
&lt;p&gt;可视化工具可以帮你 &lt;strong&gt; 了解分支的历史 &lt;/strong&gt;，比如说，你可以输入命令&lt;code&gt;git log --oneline--abbrev-commit --branches=*&lt;/code&gt; 来列出仓库中所有的 commits 的扁平化视图。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（感谢 &lt;a href=&quot;https://twitter.com/#!/cflipse&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@cflipse&lt;/a&gt; 指出 &lt;code&gt;--pretty=online&lt;/code&gt; 可以缩写为&lt;code&gt;--online&lt;/code&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/textual-git-log.png&quot; alt=&quot;textual-git-log.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;或者，你可以在上面的命令里加上&lt;code&gt;--graph&lt;/code&gt;，会得到一个稍微更有用的视图。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --oneline --abbrev-commit --branches=* --graph&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/textual-git-graph.png&quot; alt=&quot;textual-git-graph.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;好多了！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（感谢 &lt;a href=&quot;https://twitter.com/#!/mjdominus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@mjdominus&lt;/a&gt; 和 &lt;a href=&quot;https://twitter.com/#!/JRGarcia&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@JRGarcia&lt;/a&gt;提醒我可以使用&lt;code&gt;--graph&lt;/code&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你想看到分支和标签，可以加上&lt;code&gt;--decorate&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --oneline --abbrev-commit --branches=* --graph --decorate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/textual-git-graph-with-labels.png&quot; alt=&quot;textual-git-graph-with-labels.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;&lt;em&gt;（再次感谢 &lt;a href=&quot;https://twitter.com/#!/JRGarcia&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@JRGarcia&lt;/a&gt;提供的 &lt;code&gt;--decorate&lt;/code&gt; 技巧）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你也可以添加 &lt;code&gt;--color&lt;/code&gt; 来显示地更优美一点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --oneline --abbrev-commit --branches=* --graph --decorate --color&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上，我有一个 shell 的命令别名可以做到所有的这些&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alias gg=&amp;apos;git log --oneline --abbrev-commit --branches=* --graph --decorate --color&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者，你可以使用 GitX(译者注：一种 git 的 GUI 软件)看到上面所有命令的结果，并且可以看到更加清晰的图形化展示。&lt;/p&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/gitx-visualization.png&quot; alt=&quot;gitx-visualization.png&quot; title=&quot;&quot;&gt;
&lt;h3 id=&quot;引用（References）&quot;&gt;&lt;a href=&quot;# 引用（References）&quot; class=&quot;headerlink&quot; title=&quot;引用（References）&quot;&gt;&lt;/a&gt;引用（References）&lt;/h3&gt;&lt;p&gt;你可以已经注意到了上一页中 GitX 的截图里有多重颜色的标签，这些标签是 GitX 用来展示引用的。&lt;/p&gt;
&lt;p&gt;我不想花太多的时间讨论每一种颜色是什么意思，因为特定的颜色是 GitX 特有的，你可能使用的是另一种软件。但是无论你用的可视化工具如何展示这些标签，你都应该知道他们表示的含义是什么。&lt;/p&gt;
&lt;p&gt;引用是指向一次 commit 的指针。&lt;/p&gt;
&lt;p&gt;引用有几种：local branch、remote branch 和 tag。&lt;/p&gt;
&lt;p&gt;在硬盘中，一个 local branch 的引用是完全由你的工程中 &lt;code&gt;.git/refs/heads&lt;/code&gt; 目录中的一个文件组成的。这个文件包含对应 commit 的 40 字节的标识符，整个文件就是 40 个字节。&lt;/p&gt;
&lt;p&gt;你可能听说过 Git 的分支是很轻便的，这就是这句话的部分来历。在 Git 中创建分支仅仅意味着在硬盘上写入 40 个字节，这就是为什么 &lt;code&gt;git branch foo&lt;/code&gt; 是如此的快。&lt;/p&gt;
&lt;p&gt;而真正有趣的是引用的行为，所以，让我们继续。&lt;/p&gt;
&lt;h3 id=&quot;引用参考（The-Reference-Reference）&quot;&gt;&lt;a href=&quot;# 引用参考（The-Reference-Reference）&quot; class=&quot;headerlink&quot; title=&quot;引用参考（The Reference Reference）&quot;&gt;&lt;/a&gt;引用参考（The Reference Reference）&lt;/h3&gt;&lt;p&gt;正如前面所说，引用有几种不同的种类，他们都指向你仓库中的 commits。这些引用唯一的区别在于他们是如何还有何时移动的。（当我说一个引用移动的时间，我是指它指向的 commit 的 ID 改变了。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Local branch 引用 &lt;/strong&gt; 是针对一个仓库的：你本地的仓库。影响 local branch 引用的命令包括 commit, merge, rebase 和 reset。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remote branch 引用 &lt;/strong&gt; 也是针对一个仓库的，但是那个先前被指定为远程的仓库。影响 remote branch 引用的命令包括 fetch 和 push。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tag 引用 &lt;/strong&gt; 基本上可以 branch 引用一样，但是它们不会移动。&lt;strong&gt;一旦你创建一个 tag，它就不再改变了 &lt;/strong&gt;（除非你明确地使用&lt;code&gt;--force&lt;/code&gt; 命令选项更新它）。这种行为使 tag 可以用来比标记特定版本的软件包，或者标记一个特定的日期生产服务器中部署了什么。据我所知，只有一个命令影响 tag，那就是 tag。&lt;/p&gt;
&lt;h3 id=&quot;Making-Sense-of-the-Display&quot;&gt;&lt;a href=&quot;#Making-Sense-of-the-Display&quot; class=&quot;headerlink&quot; title=&quot;Making Sense of the Display&quot;&gt;&lt;/a&gt;Making Sense of the Display&lt;/h3&gt;&lt;p&gt;这是另一张有一些注解的 GitX 的截图。&lt;/p&gt;
&lt;img src=&quot;/2016/04/08/think-like-a-git/gitx-visualization-annotated.png&quot; alt=&quot;gitx-visualization-annotated.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果你想要一个仓库样本随便玩玩，可以&lt;a href=&quot;(https://github.com/geeksam/do-re-mi&quot;&gt;clone 这个&lt;/a&gt;)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这张图最重要的不是你看到的，而是你 &lt;strong&gt; 没有 &lt;/strong&gt; 看到的。我看过的所有 Git 工具都有一个共同点：&lt;strong&gt;他们隐藏了 commits&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;听起来像个阴谋论，对吧？其实并不是这样。&lt;/p&gt;
&lt;h3 id=&quot;垃圾回收（Garbage-Collection）&quot;&gt;&lt;a href=&quot;# 垃圾回收（Garbage-Collection）&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收（Garbage Collection）&quot;&gt;&lt;/a&gt;垃圾回收（Garbage Collection）&lt;/h3&gt;&lt;p&gt;想象这样一个场景，你写了一些代码并且 check in 了，然后你发现忘记运行测试用例了，所以你运行了测试用例，并且发现了一个语法错误。或者你认出一个拼写错误。无论因为什么原因，当你任务你做完的时候你实际并没有做完。（我经常干这种事）&lt;/p&gt;
&lt;p&gt;回到我使用 Subvesion 的的时间，唯一能做的是在另个一个 commit 中增加新的修改。通常，在提交历史中我会有三到四个版本。第一个版本是”add feature X”，而下一个版本就是 “oops, found typo”或者”bugfix”或者”forgot to run tests”。&lt;/p&gt;
&lt;p&gt;Git 给了你另一种选择。你可以使用 &lt;code&gt;git commit —amend&lt;/code&gt; 命令将新的修改放到之前 commit 中。这样可以将所有相关的修改都绑定到一次 commit 上，当你以后回顾的时候也可以更快的弄明白。&lt;/p&gt;
&lt;p&gt;另一个关于 Git commit 的事实是：一个 commit 的 ID 是一个由以下几种信息组成的 &lt;a href=&quot;http://en.wikipedia.org/wiki/SHA-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SHA-1hash&lt;/a&gt; 值：commit 的内容和 parent commit 的 ID。&lt;/p&gt;
&lt;p&gt;也就是说，当你使用 &lt;code&gt;git commit —amend&lt;/code&gt; 的时候，你实际上创建了一个完全不同的 commit，并将 local branch 引用指向了这个 commit。&lt;strong&gt;第一个 commit 还在硬盘上，你仍然可以找回他 &lt;/strong&gt;（稍后介绍）。但是，为了避免混乱的展示效果，&lt;code&gt;git log&lt;/code&gt; 和 Git 可视化工具都展示之前的 commit。&lt;/p&gt;
&lt;p&gt;最终，Git 会决定何时启动 &lt;a href=&quot;http://en.wikipedia.org/wiki/Garbage_collection_(computer_science&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;garbage collection&lt;/a&gt;#Reachability_of_an_object)。（你也可以使用&lt;code&gt;git gc&lt;/code&gt; 自己触发这个流程）。从每一个 branch 和 tag 开始，Git 沿着相反的方向走过整张图，得到它所能到达的所有 commit 的列表。一旦它到达每一条路径的重点，就会把所有没有访问到的 commit 删除。&lt;/p&gt;
&lt;h2 id=&quot;试试 Git（Experimenting-With-Git）&quot;&gt;&lt;a href=&quot;# 试试 Git（Experimenting-With-Git）&quot; class=&quot;headerlink&quot; title=&quot;试试 Git（Experimenting With Git）&quot;&gt;&lt;/a&gt;试试 Git（Experimenting With Git）&lt;/h2&gt;&lt;p&gt;我在前一页说了一些非常重要的东西，这种东西是如此重要以致于我要重复一遍。&lt;/p&gt;
&lt;p&gt;在描述 Git 的垃圾回收算法时，我说“&lt;strong&gt;从每一个 branch 和 tag 开始&lt;/strong&gt;，Git 沿着相反的方向走过整张图，得到它所能到达的所有 commit 的列表。”&lt;/p&gt;
&lt;p&gt;到此为止我写的所有的东西都是为了帮助你 &lt;strong&gt; 理解一个特定的事情 &lt;/strong&gt; 而提供的背景知识。如果我只有十秒钟来告诉你 Git 的秘密，也是整篇文章的精髓，我把它整合成四个词：&lt;/p&gt;
&lt;h3 id=&quot;References-Make-Commits-Reachable&quot;&gt;&lt;a href=&quot;#References-Make-Commits-Reachable&quot; class=&quot;headerlink&quot; title=&quot;References Make Commits Reachable&quot;&gt;&lt;/a&gt;References Make Commits Reachable&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;REFERENCES MAKE COMMITS REACHABLE.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们分解来看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REFERENCES…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;…无论他们是 local branch 引用，remote branch 引用，还是 tag 引用…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;…MAKE COMMITS…&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;…也就是图中的节点…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;…REACHABLE.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;…所以你可以沿着相反的方向到达它们，而且 Git 在做垃圾回收的时候不会删除他们。&lt;/p&gt;
&lt;p&gt;将这句话凑在一起花了我很长的时间，我写这篇文章的目的就是让你不必浪费我花费过的时间。&lt;/p&gt;
&lt;h3 id=&quot;我拙劣的初学（My-Humble-Beginnings）&quot;&gt;&lt;a href=&quot;# 我拙劣的初学（My-Humble-Beginnings）&quot; class=&quot;headerlink&quot; title=&quot;我拙劣的初学（My Humble Beginnings）&quot;&gt;&lt;/a&gt;我拙劣的初学（My Humble Beginnings）&lt;/h3&gt;&lt;h3 id=&quot;将分支当做存档点（Branches-as-Savepoints）&quot;&gt;&lt;a href=&quot;# 将分支当做存档点（Branches-as-Savepoints）&quot; class=&quot;headerlink&quot; title=&quot;将分支当做存档点（Branches as Savepoints）&quot;&gt;&lt;/a&gt;将分支当做存档点（Branches as Savepoints）&lt;/h3&gt;&lt;h3 id=&quot;Use-Your-Targeting-Computer-Luke&quot;&gt;&lt;a href=&quot;#Use-Your-Targeting-Computer-Luke&quot; class=&quot;headerlink&quot; title=&quot;Use Your Targeting Computer, Luke&quot;&gt;&lt;/a&gt;Use Your Targeting Computer, Luke&lt;/h3&gt;&lt;h2 id=&quot;测试一下合并（Testing-Out-Merges）&quot;&gt;&lt;a href=&quot;# 测试一下合并（Testing-Out-Merges）&quot; class=&quot;headerlink&quot; title=&quot;测试一下合并（Testing Out Merges）&quot;&gt;&lt;/a&gt;测试一下合并（Testing Out Merges）&lt;/h2&gt;&lt;h3 id=&quot;The-Scout-Pattern&quot;&gt;&lt;a href=&quot;#The-Scout-Pattern&quot; class=&quot;headerlink&quot; title=&quot;The Scout Pattern&quot;&gt;&lt;/a&gt;The Scout Pattern&lt;/h3&gt;&lt;h3 id=&quot;The-Savepoint-Pattern&quot;&gt;&lt;a href=&quot;#The-Savepoint-Pattern&quot; class=&quot;headerlink&quot; title=&quot;The Savepoint Pattern&quot;&gt;&lt;/a&gt;The Savepoint Pattern&lt;/h3&gt;&lt;h3 id=&quot;Black-Belt-Merging&quot;&gt;&lt;a href=&quot;#Black-Belt-Merging&quot; class=&quot;headerlink&quot; title=&quot;Black Belt Merging&quot;&gt;&lt;/a&gt;Black Belt Merging&lt;/h3&gt;&lt;h2 id=&quot;Rebase（Rebase-From-the-Ground-Up）&quot;&gt;&lt;a href=&quot;#Rebase（Rebase-From-the-Ground-Up）&quot; class=&quot;headerlink&quot; title=&quot;Rebase（Rebase From the Ground Up）&quot;&gt;&lt;/a&gt;Rebase（Rebase From the Ground Up）&lt;/h2&gt;&lt;h3 id=&quot;Cherry-Picking-Explained&quot;&gt;&lt;a href=&quot;#Cherry-Picking-Explained&quot; class=&quot;headerlink&quot; title=&quot;Cherry-Picking Explained&quot;&gt;&lt;/a&gt;Cherry-Picking Explained&lt;/h3&gt;&lt;h3 id=&quot;Using-‘git-cherry-pick’-to-Simulate-‘git-rebase’&quot;&gt;&lt;a href=&quot;#Using-‘git-cherry-pick’-to-Simulate-‘git-rebase’&quot; class=&quot;headerlink&quot; title=&quot;Using ‘git cherry-pick’ to Simulate ‘git rebase’&quot;&gt;&lt;/a&gt;Using ‘git cherry-pick’ to Simulate ‘git rebase’&lt;/h3&gt;&lt;h3 id=&quot;A-Helpful-Mnemonic-for-‘git-rebase’-Arguments&quot;&gt;&lt;a href=&quot;#A-Helpful-Mnemonic-for-‘git-rebase’-Arguments&quot; class=&quot;headerlink&quot; title=&quot;A Helpful Mnemonic for ‘git rebase’ Arguments&quot;&gt;&lt;/a&gt;A Helpful Mnemonic for ‘git rebase’ Arguments&lt;/h3&gt;&lt;h2 id=&quot;The-End&quot;&gt;&lt;a href=&quot;#The-End&quot; class=&quot;headerlink&quot; title=&quot;The End&quot;&gt;&lt;/a&gt;The End&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;译者注：本文翻译自 Sam Livingston-Gray 的文章&lt;a href=&quot;http://think-like-a-git.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Think Like (a) Git&lt;/a&gt;。我在学习 Git 的过
    
    </summary>
    
      <category term="Git" scheme="http://zqchen90.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://zqchen90.github.io/tags/Git/"/>
    
      <category term="翻译" scheme="http://zqchen90.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>React 实现添加千分位的 Input</title>
    <link href="http://zqchen90.github.io/2016/04/06/react-money-input/"/>
    <id>http://zqchen90.github.io/2016/04/06/react-money-input/</id>
    <published>2016-04-06T02:51:34.000Z</published>
    <updated>2016-04-07T06:48:20.000Z</updated>
    
    <content type="html">&lt;p&gt;有这样一个需求，用户在 input 中输入金额，为了展示效果，需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入时，自动添加千分位&lt;/li&gt;
&lt;li&gt;输入结束，提交时仍提交数字（不包含千分位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为最近正在学习 React.js，就试着练练手，用 React 实现满足上述需求的 input 组件。&lt;/p&gt;
&lt;h2 id=&quot;千分位&quot;&gt;&lt;a href=&quot;# 千分位&quot; class=&quot;headerlink&quot; title=&quot;千分位&quot;&gt;&lt;/a&gt;千分位 &lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/%E5%B0%8F%E6%95%B8%E9%BB%9E#.E6.95.B0-.7B.E5.AD.97.7D-.E5.88.86.E4.BD.8D.E7.AC.A6.E5.8F.B7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 维基百科 &lt;/a&gt; 对千分位有清楚的说明，这里只举一个例子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;123456.9876&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的千分位是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;123,456.987,6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外千分位可以用逗号，也可以用空格。这里就不做区分，都只用逗号表示。&lt;/p&gt;
&lt;p&gt;对数字添加千分位的 js 实现也有 &lt;a href=&quot;http://heeroluo.net/article/detail/115&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 很多&lt;/a&gt;，这里就选最简单的一种。&lt;/p&gt;
&lt;h3 id=&quot;添加千分位：&quot;&gt;&lt;a href=&quot;# 添加千分位：&quot; class=&quot;headerlink&quot; title=&quot;添加千分位：&quot;&gt;&lt;/a&gt;添加千分位：&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; amount = &lt;span class=&quot;string&quot;&gt;&#39;123456.9876&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; amountThusandth = amount.replace(&lt;span class=&quot;regexp&quot;&gt;/(\d)(?=(\d&amp;#123;3&amp;#125;)+(?:\.\d+)?$)/g&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;$1,&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;去除千分位：&quot;&gt;&lt;a href=&quot;# 去除千分位：&quot; class=&quot;headerlink&quot; title=&quot;去除千分位：&quot;&gt;&lt;/a&gt;去除千分位：&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; amountThusandth = &lt;span class=&quot;string&quot;&gt;&#39;123,456.987,6&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; amount = amountThusandth.replace(&lt;span class=&quot;regexp&quot;&gt;/,/g&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过需要提醒一下，&lt;strong&gt;不要使用 toLocaleString()&lt;/strong&gt;，toLocaleString 函数无法对小数部分添加千分位，并且在不同浏览器的效果不同。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;&lt;a href=&quot;# 实现&quot; class=&quot;headerlink&quot; title=&quot;实现&quot;&gt;&lt;/a&gt;实现&lt;/h2&gt;&lt;p&gt;React.js 对我来说，是一种全新的思考套路，如果不熟悉 React 的话，非常建议先阅读下面这两篇文章：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003501752#articleHeader5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React.js 的介绍 - 针对了解 jQuery 的工程师&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.zh-CN.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React 编程思想&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对输入的数字添加千分位这个问题，实际上是一个很典型的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用一个 state 来保存添加千分位的结果&lt;/li&gt;
&lt;li&gt;input 的 value 由 state 设置&lt;/li&gt;
&lt;li&gt;在 input 的 onChange 中，处理用户输入的值，并通过 this.setState 更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h2&gt;&lt;iframe scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;300&quot; src=&quot;http://jsfiddle.net/hqaz7kgh/embedded/js,resources,html,css,result/light&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;# 参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考 &lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/%E5%B0%8F%E6%95%B8%E9%BB%9E#.E6.95.B0-.7B.E5.AD.97.7D-.E5.88.86.E4.BD.8D.E7.AC.A6.E5.8F.B7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 小數點 - 维基百科 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://heeroluo.net/article/detail/115&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 从千分位格式化谈 JS 性能优化&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000003501752#articleHeader5&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React.js 的介绍 - 针对了解 jQuery 的工程师&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://facebook.github.io/react/docs/thinking-in-react.zh-CN.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React 编程思想&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一个需求，用户在 input 中输入金额，为了展示效果，需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入时，自动添加千分位&lt;/li&gt;
&lt;li&gt;输入结束，提交时仍提交数字（不包含千分位）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为最近正在学习 React.js，就试着练练手，用 Rea
    
    </summary>
    
      <category term="React" scheme="http://zqchen90.github.io/categories/React/"/>
    
    
      <category term="React" scheme="http://zqchen90.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Python 使用 ElementTree 处理 XML</title>
    <link href="http://zqchen90.github.io/2016/04/05/python-element-tree/"/>
    <id>http://zqchen90.github.io/2016/04/05/python-element-tree/</id>
    <published>2016-04-05T11:19:53.000Z</published>
    <updated>2016-04-07T06:15:43.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;ElementTree&lt;/strong&gt;是 Python 常用的处理 XML 文件的类。本文将介绍使用 ElementTree 解析、查找、修改 XML 的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、引用方法&quot;&gt;&lt;a href=&quot;# 一、引用方法&quot; class=&quot;headerlink&quot; title=&quot;一、引用方法&quot;&gt;&lt;/a&gt;一、引用方法&lt;/h2&gt;&lt;p&gt;ElementTree 所在文件保存在 Lib/xml/etree/ElementTree.py，所以我们通过下面的代码引用它，之后就可以使用 ET. 来访问 ElementTree 中的函数。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; xml.etree.ElementTree &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ET&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、一个 XML 例子&quot;&gt;&lt;a href=&quot;# 二、一个 XML 例子&quot; class=&quot;headerlink&quot; title=&quot;二、一个 XML 例子&quot;&gt;&lt;/a&gt;二、一个 XML 例子 &lt;/h2&gt;&lt;p&gt; 下面所有的操作都将下面这段 XML 为例，我们将它保存为&lt;strong&gt;sample.xml&lt;/strong&gt;。&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Liechtenstein&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;2008&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;141100&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Austria&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;direction&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;E&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Switzerland&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;direction&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;W&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Singapore&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;4&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;2011&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;59900&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Malaysia&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;direction&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;N&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Panama&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;68&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;rank&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;2011&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;year&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;13600&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;gdppc&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Costa Rica&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;direction&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;W&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Colombia&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;direction&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;E&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;country&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;data&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先对 XML 的格式做一些说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tag&lt;/strong&gt;： 使用 &amp;lt; 和 &amp;gt; 包围的部分，如 &lt;rank&gt; 成为 start-tag，&lt;/rank&gt;是 end-tags；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Element&lt;/strong&gt;：被 Tag 包围的部分，如&lt;rank&gt;68&lt;/rank&gt;，可以认为是一个节点，它可以有子节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Attribute&lt;/strong&gt;：在 Tag 中可能存在的 name/value 对，如 &lt;country name=&quot;Liechtenstein&quot;&gt; 中的 name=”Liechtenstein”，一般表示属性。&lt;/country&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三、解析 XML&quot;&gt;&lt;a href=&quot;# 三、解析 XML&quot; class=&quot;headerlink&quot; title=&quot;三、解析 XML&quot;&gt;&lt;/a&gt;三、解析 XML&lt;/h2&gt;&lt;h3 id=&quot;读入 XML 数据&quot;&gt;&lt;a href=&quot;# 读入 XML 数据&quot; class=&quot;headerlink&quot; title=&quot;读入 XML 数据&quot;&gt;&lt;/a&gt;读入 XML 数据 &lt;/h3&gt;&lt;p&gt; 首先读入 XML，有两种途径，从文件读入和从字符串读入。&lt;br&gt;从文件读入：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; xml.etree.ElementTree &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ET&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tree = ET.parse(&lt;span class=&quot;string&quot;&gt;&#39;sample.xml&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root = tree.getroot()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从字符串读入：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root = ET.fromstring(sample_as_string)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tree 和 root 分布是 ElementTree 中两个很重要的类的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ElementTree&lt;/li&gt;
&lt;li&gt;Element&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;查看 Tag 和 Attribute&quot;&gt;&lt;a href=&quot;# 查看 Tag 和 Attribute&quot; class=&quot;headerlink&quot; title=&quot;查看 Tag 和 Attribute&quot;&gt;&lt;/a&gt;查看 Tag 和 Attribute&lt;/h3&gt;&lt;p&gt;这时得到的 root 是一个指向&lt;data&gt;Element 对象，我们可以通过查看 root 的 tag 和 attrib 来验证这一点：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;root.tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;root.attrib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/data&gt;&lt;/p&gt;
&lt;p&gt;上面的代码说明了查看一个 Element 的 Tag 和 Attribute 的方法，Tag 是一个 &lt;em&gt; 字符串 &lt;/em&gt;，而 Attribute 得到的是一个&lt;em&gt; 字典&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;另外，还可以使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Element.get(AttributeName)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来代替 Element.attrib[AttributeName]来访问。&lt;/p&gt;
&lt;h3 id=&quot;查看孩子&quot;&gt;&lt;a href=&quot;# 查看孩子&quot; class=&quot;headerlink&quot; title=&quot;查看孩子&quot;&gt;&lt;/a&gt;查看孩子&lt;/h3&gt;&lt;p&gt;root.attrib 返回的是一个空字典，如果看 root 的孩子，可以得到非空的 attrib 字典。&lt;/p&gt;
&lt;h4 id=&quot;1、使用 for…in…访问&quot;&gt;&lt;a href=&quot;#1、使用 for…in…访问&quot; class=&quot;headerlink&quot; title=&quot;1、使用 for…in…访问&quot;&gt;&lt;/a&gt;1、使用 for…in…访问&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; child &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; child.tag, child.attrib&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;得到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;country {‘name’: ‘Liechtenstein’}&lt;br&gt;country {‘name’: ‘Singapore’}&lt;br&gt;country {‘name’: ‘Panama’}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;2、使用下标访问&quot;&gt;&lt;a href=&quot;#2、使用下标访问&quot; class=&quot;headerlink&quot; title=&quot;2、使用下标访问&quot;&gt;&lt;/a&gt;2、使用下标访问 &lt;/h4&gt;&lt;p&gt; 如:&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; root[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;country&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; root[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].tag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rank&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;3、使用 Tag 名称访问&quot;&gt;&lt;a href=&quot;#3、使用 Tag 名称访问&quot; class=&quot;headerlink&quot; title=&quot;3、使用 Tag 名称访问&quot;&gt;&lt;/a&gt;3、使用 Tag 名称访问 &lt;/h4&gt;&lt;p&gt; 下标访问的方法虽然简单，但是在未知 XML 具体结构的时候并不适用，通过 Tag 名称访问的方法更具有普适性。这里用到 Element 类的几个函数，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Element.iter()&lt;/li&gt;
&lt;li&gt;Element.findall()&lt;/li&gt;
&lt;li&gt;Element.find()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个函数使用的场景有所差异：&lt;br&gt;&lt;strong&gt;Element.iter()&lt;/strong&gt;用来寻找 &lt;strong&gt; 所有 &lt;/strong&gt; 符合要求的 Tag，注意，这里查找的范围 &lt;strong&gt; 是所有孩子和孩子的孩子 and so on&lt;/strong&gt;。如果查看所有的 year，可以使用下面的代码：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; neighbor &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root.iter(&lt;span class=&quot;string&quot;&gt;&#39;year&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; neighbor.text&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2008&lt;br&gt;2011&lt;br&gt;2011&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Element.findall()&lt;/strong&gt;只查找 &lt;strong&gt; 直接的孩子 &lt;/strong&gt;，返回所有符合要求的 Tag 的 Element，而&lt;strong&gt;Element.find()&lt;/strong&gt; 只返回符合要求的第一个 Element。如果查看 Singapore 的 year 的值，可以使用下面的代码：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; country &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root.findall(&lt;span class=&quot;string&quot;&gt;&#39;country&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; country.attrib[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;Singapore&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            year = country.find(&lt;span class=&quot;string&quot;&gt;&#39;year&#39;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 使用 Element.find()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; year.text&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; country &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root.findall(&lt;span class=&quot;string&quot;&gt;&#39;country&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; country.attrib[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;] == &lt;span class=&quot;string&quot;&gt;&#39;Singapore&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            years = country.findall(&lt;span class=&quot;string&quot;&gt;&#39;year&#39;&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# 使用 Element.findall()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; years[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].text  &lt;span class=&quot;comment&quot;&gt;# 注意和上段的区别&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看 Element 的值&quot;&gt;&lt;a href=&quot;# 查看 Element 的值&quot; class=&quot;headerlink&quot; title=&quot;查看 Element 的值&quot;&gt;&lt;/a&gt;查看 Element 的值 &lt;/h3&gt;&lt;p&gt; 我们可以直接用 Element.text 来得到这个 Element 的值。&lt;/p&gt;
&lt;h2 id=&quot;四、修改 XML&quot;&gt;&lt;a href=&quot;# 四、修改 XML&quot; class=&quot;headerlink&quot; title=&quot;四、修改 XML&quot;&gt;&lt;/a&gt;四、修改 XML&lt;/h2&gt;&lt;p&gt;前面已经介绍了如何获取一个 Element 的对象，以及查看它的 Tag、Attribute、值和它的孩子。下面介绍如何修改一个 Element 并对 XML 文件进行保存&lt;/p&gt;
&lt;h3 id=&quot;修改 Element&quot;&gt;&lt;a href=&quot;# 修改 Element&quot; class=&quot;headerlink&quot; title=&quot;修改 Element&quot;&gt;&lt;/a&gt;修改 Element&lt;/h3&gt;&lt;p&gt;修改 Element 可以直接访问 Element.text。&lt;br&gt;修改 Element 的 Attribute，也可以用来新增 Attribute：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Element.set(‘AttributeName’,’AttributeValue’)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新增孩子节点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Element.append(childElement)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;删除孩子节点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Element.remove(childElement)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;保存 XML&quot;&gt;&lt;a href=&quot;# 保存 XML&quot; class=&quot;headerlink&quot; title=&quot;保存 XML&quot;&gt;&lt;/a&gt;保存 XML&lt;/h3&gt;&lt;p&gt;我们从文件解析的时候，我们用了一个 ElementTree 的对象 tree，在完成修改之后，还用 tree 来保存 XML 文件。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tree.write(&lt;span class=&quot;string&quot;&gt;&#39;output.xml&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;构建 XML&quot;&gt;&lt;a href=&quot;# 构建 XML&quot; class=&quot;headerlink&quot; title=&quot;构建 XML&quot;&gt;&lt;/a&gt;构建 XML&lt;/h3&gt;&lt;p&gt;ElementTree 提供了两个静态函数（直接用类名访问，这里我们用的是 ET）可以很方便的构建一个 XML，如：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root = ET.Element(&lt;span class=&quot;string&quot;&gt;&#39;data&#39;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    country = ET.SubElement(root,&lt;span class=&quot;string&quot;&gt;&#39;country&#39;&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;Liechtenstein&#39;&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rank = ET.SubElement(country,&lt;span class=&quot;string&quot;&gt;&#39;rank&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rank.text = &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    year = ET.SubElement(country,&lt;span class=&quot;string&quot;&gt;&#39;year&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    year.text = &lt;span class=&quot;string&quot;&gt;&#39;2008&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ET.dump(root)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以得到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;data&gt;&lt;country name=&quot;Liechtenstein&quot;&gt;&lt;rank&gt;1&lt;/rank&gt;&lt;year&gt;2008&lt;/year&gt;&lt;/country&gt;&lt;/data&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;五、XPath 支持&quot;&gt;&lt;a href=&quot;# 五、XPath 支持&quot; class=&quot;headerlink&quot; title=&quot;五、XPath 支持&quot;&gt;&lt;/a&gt;五、XPath 支持&lt;/h2&gt;&lt;p&gt;XPath 表达式用来在 XML 中定位 Element，下面给一个例子来说明：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; xml.etree.ElementTree &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; ET&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root = ET.fromstring(countrydata)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Top-level elements&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.findall(&lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# All &#39;neighbor&#39; grand-children of &#39;country&#39; children of the top-level&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# elements&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.findall(&lt;span class=&quot;string&quot;&gt;&quot;./country/neighbor&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Nodes with name=&#39;Singapore&#39; that have a &#39;year&#39; child&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.findall(&lt;span class=&quot;string&quot;&gt;&quot;.//year/..[@name=&#39;Singapore&#39;]&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# &#39;year&#39; nodes that are children of nodes with name=&#39;Singapore&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.findall(&lt;span class=&quot;string&quot;&gt;&quot;.//*[@name=&#39;Singapore&#39;]/year&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# All &#39;neighbor&#39; nodes that are the second child of their parent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root.findall(&lt;span class=&quot;string&quot;&gt;&quot;.//neighbor[2]&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;# 参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://effbot.org/zone/element-index.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ElementTree 主页&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://docs.python.org/2/library/xml.etree.elementtree.html#reference&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ElementTree 的函数与类介绍&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2014/5/30&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ElementTree&lt;/strong&gt;是 Python 常用的处理 XML 文件的类。本文将介绍使用 ElementTree 解析、查找、修改 XML 的方法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、引用方法&quot;&gt;&lt;a href=&quot;# 一、引用方法&quot; cla
    
    </summary>
    
      <category term="Python" scheme="http://zqchen90.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://zqchen90.github.io/tags/Python/"/>
    
      <category term="XML" scheme="http://zqchen90.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zqchen90.github.io/2016/04/05/hello-world/"/>
    <id>http://zqchen90.github.io/2016/04/05/hello-world/</id>
    <published>2016-04-05T07:40:45.000Z</published>
    <updated>2016-04-05T09:57:47.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to my blog! This is your my first post and Hello world!&lt;/p&gt;
&lt;p&gt;If you want to know more about me, please refer to &lt;a href=&quot;/about/&quot;&gt;About Me&lt;/a&gt;.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog! This is your my first post and Hello world!&lt;/p&gt;
&lt;p&gt;If you want to know more about me, please refer to &lt;a href=&quot;/about
    
    </summary>
    
    
  </entry>
  
</feed>
